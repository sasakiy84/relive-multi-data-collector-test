// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: event.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    name,
    description
) VALUES (
    $1,
    coalesce($2::text, '')
)
RETURNING
    id, name, description, created_at, updated_at
`

type CreateEventParams struct {
	Name        string  `json:"name"`
	Description *string `json:"description"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent, arg.Name, arg.Description)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventById = `-- name: GetEventById :one
SELECT
    id, name, description, created_at, updated_at
FROM
    events
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) GetEventById(ctx context.Context, id pgtype.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEventById, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventByName = `-- name: GetEventByName :one
SELECT
    id, name, description, created_at, updated_at
FROM
    events
WHERE
    name = $1
LIMIT
    1
`

func (q *Queries) GetEventByName(ctx context.Context, name string) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByName, name)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventsByIds = `-- name: GetEventsByIds :many
SELECT
    id, name, description, created_at, updated_at
FROM
    events
WHERE
    id = ANY($1::text[])
ORDER BY
    created_at DESC, id DESC
LIMIT
    coalesce($2::int, 10)
`

type GetEventsByIdsParams struct {
	Ids   []string `json:"ids"`
	Limit *int32   `json:"limit"`
}

func (q *Queries) GetEventsByIds(ctx context.Context, arg GetEventsByIdsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByIds, arg.Ids, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateEventById = `-- name: GetOrCreateEventById :one
WITH inserted_event AS (
    INSERT INTO events (
        name
    ) VALUES (
        $1
    )
    ON CONFLICT (name) DO NOTHING
    RETURNING
        id, name, description, created_at, updated_at, true AS created
)
(SELECT id, name, description, created_at, updated_at, created FROM inserted_event)
UNION ALL
(SELECT id, name, description, created_at, updated_at, false AS created FROM events WHERE name = $1)
LIMIT 1
`

type GetOrCreateEventByIdRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	Created     bool               `json:"created"`
}

func (q *Queries) GetOrCreateEventById(ctx context.Context, name string) (GetOrCreateEventByIdRow, error) {
	row := q.db.QueryRow(ctx, getOrCreateEventById, name)
	var i GetOrCreateEventByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Created,
	)
	return i, err
}

const listEvents = `-- name: ListEvents :many
SELECT
    id, name, description, created_at, updated_at
FROM
    events
ORDER BY
    created_at DESC, id DESC
LIMIT
    coalesce($1::int, 10)
`

func (q *Queries) ListEvents(ctx context.Context, limit *int32) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
