// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: video.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createThumbnail = `-- name: CreateThumbnail :one
INSERT INTO thumbnails (
    url,
    type,
    width,
    height,
    youtube_video_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING
    url, type, width, height, youtube_video_id
`

type CreateThumbnailParams struct {
	Url            string        `json:"url"`
	Type           ThumbnailType `json:"type"`
	Width          int32         `json:"width"`
	Height         int32         `json:"height"`
	YoutubeVideoID string        `json:"youtube_video_id"`
}

func (q *Queries) CreateThumbnail(ctx context.Context, arg CreateThumbnailParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, createThumbnail,
		arg.Url,
		arg.Type,
		arg.Width,
		arg.Height,
		arg.YoutubeVideoID,
	)
	var i Thumbnail
	err := row.Scan(
		&i.Url,
		&i.Type,
		&i.Width,
		&i.Height,
		&i.YoutubeVideoID,
	)
	return i, err
}

type CreateThumbnailsParams struct {
	Url            string        `json:"url"`
	Type           ThumbnailType `json:"type"`
	Width          int32         `json:"width"`
	Height         int32         `json:"height"`
	YoutubeVideoID string        `json:"youtube_video_id"`
}

const getOrCreateVideo = `-- name: GetOrCreateVideo :one
WITH inserted_video AS (
    INSERT INTO videos (
        youtube_video_id,
        title,
        actual_end_time,
        actual_start_time,
        view_count,
        like_count,
        duration_second,
        youtube_channel_id,
        event_id
    ) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    )
    ON CONFLICT (youtube_video_id) DO NOTHING
    RETURNING
        youtube_video_id, title, actual_end_time, actual_start_time, view_count, like_count, duration_second, youtube_channel_id, event_id, created_at, updated_at, true AS created
)
SELECT
    youtube_video_id, title, actual_end_time, actual_start_time, view_count, like_count, duration_second, youtube_channel_id, event_id, created_at, updated_at, created
FROM
    inserted_video
UNION ALL
(SELECT
    youtube_video_id, title, actual_end_time, actual_start_time, view_count, like_count, duration_second, youtube_channel_id, event_id, created_at, updated_at, false AS created
FROM
    videos
WHERE
    youtube_video_id = $1)
LIMIT
    1
`

type GetOrCreateVideoParams struct {
	YoutubeVideoID   string             `json:"youtube_video_id"`
	Title            string             `json:"title"`
	ActualEndTime    pgtype.Timestamptz `json:"actual_end_time"`
	ActualStartTime  pgtype.Timestamptz `json:"actual_start_time"`
	ViewCount        int64              `json:"view_count"`
	LikeCount        int64              `json:"like_count"`
	DurationSecond   int32              `json:"duration_second"`
	YoutubeChannelID string             `json:"youtube_channel_id"`
	EventID          pgtype.UUID        `json:"event_id"`
}

type GetOrCreateVideoRow struct {
	YoutubeVideoID   string             `json:"youtube_video_id"`
	Title            string             `json:"title"`
	ActualEndTime    pgtype.Timestamptz `json:"actual_end_time"`
	ActualStartTime  pgtype.Timestamptz `json:"actual_start_time"`
	ViewCount        int64              `json:"view_count"`
	LikeCount        int64              `json:"like_count"`
	DurationSecond   int32              `json:"duration_second"`
	YoutubeChannelID string             `json:"youtube_channel_id"`
	EventID          pgtype.UUID        `json:"event_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	Created          bool               `json:"created"`
}

func (q *Queries) GetOrCreateVideo(ctx context.Context, arg GetOrCreateVideoParams) (GetOrCreateVideoRow, error) {
	row := q.db.QueryRow(ctx, getOrCreateVideo,
		arg.YoutubeVideoID,
		arg.Title,
		arg.ActualEndTime,
		arg.ActualStartTime,
		arg.ViewCount,
		arg.LikeCount,
		arg.DurationSecond,
		arg.YoutubeChannelID,
		arg.EventID,
	)
	var i GetOrCreateVideoRow
	err := row.Scan(
		&i.YoutubeVideoID,
		&i.Title,
		&i.ActualEndTime,
		&i.ActualStartTime,
		&i.ViewCount,
		&i.LikeCount,
		&i.DurationSecond,
		&i.YoutubeChannelID,
		&i.EventID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Created,
	)
	return i, err
}

const getVideoById = `-- name: GetVideoById :one
SELECT
    videos.youtube_video_id, videos.title, videos.actual_end_time, videos.actual_start_time, videos.view_count, videos.like_count, videos.duration_second, videos.youtube_channel_id, videos.event_id, videos.created_at, videos.updated_at,
    channels.name AS channel_name,
    thumbnails.url AS thumbnail_url,
    thumbnails.type AS thumbnail_type
FROM
    videos
JOIN
    channels
ON
    videos.youtube_channel_id = channels.youtube_channel_id
JOIN
    thumbnails
ON
    videos.youtube_video_id = thumbnails.youtube_video_id
WHERE
    videos.youtube_video_id = $1
ORDER BY
    CASE 
        WHEN thumbnails.type = 'default' THEN 1
        WHEN thumbnails.type = 'medium' THEN 2
        WHEN thumbnails.type = 'high' THEN 3
        WHEN thumbnails.type = 'standard' THEN 4
        WHEN thumbnails.type = 'maxres' THEN 5
        ELSE 99
    END
LIMIT
    1
`

type GetVideoByIdRow struct {
	YoutubeVideoID   string             `json:"youtube_video_id"`
	Title            string             `json:"title"`
	ActualEndTime    pgtype.Timestamptz `json:"actual_end_time"`
	ActualStartTime  pgtype.Timestamptz `json:"actual_start_time"`
	ViewCount        int64              `json:"view_count"`
	LikeCount        int64              `json:"like_count"`
	DurationSecond   int32              `json:"duration_second"`
	YoutubeChannelID string             `json:"youtube_channel_id"`
	EventID          pgtype.UUID        `json:"event_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ChannelName      string             `json:"channel_name"`
	ThumbnailUrl     string             `json:"thumbnail_url"`
	ThumbnailType    ThumbnailType      `json:"thumbnail_type"`
}

func (q *Queries) GetVideoById(ctx context.Context, youtubeVideoID string) (GetVideoByIdRow, error) {
	row := q.db.QueryRow(ctx, getVideoById, youtubeVideoID)
	var i GetVideoByIdRow
	err := row.Scan(
		&i.YoutubeVideoID,
		&i.Title,
		&i.ActualEndTime,
		&i.ActualStartTime,
		&i.ViewCount,
		&i.LikeCount,
		&i.DurationSecond,
		&i.YoutubeChannelID,
		&i.EventID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChannelName,
		&i.ThumbnailUrl,
		&i.ThumbnailType,
	)
	return i, err
}

const getVideosByEventId = `-- name: GetVideosByEventId :many
SELECT
    videos.youtube_video_id, videos.title, videos.actual_end_time, videos.actual_start_time, videos.view_count, videos.like_count, videos.duration_second, videos.youtube_channel_id, videos.event_id, videos.created_at, videos.updated_at,
    channels.name AS channel_name,
    picked_thumbnails.url AS thumbnail_url,
    picked_thumbnails.type AS thumbnail_type,
    picked_thumbnails.width AS thumbnail_width,
    picked_thumbnails.height AS thumbnail_height
FROM
    videos
JOIN
    channels
ON
    videos.youtube_channel_id = channels.youtube_channel_id
LEFT JOIN LATERAL (
    SELECT
        url, type, width, height, youtube_video_id
    FROM
        thumbnails
    WHERE
        thumbnails.youtube_video_id = videos.youtube_video_id
    ORDER BY
        CASE 
            WHEN thumbnails.type = 'default' THEN 4
            WHEN thumbnails.type = 'medium' THEN 2
            WHEN thumbnails.type = 'high' THEN 3
            WHEN thumbnails.type = 'standard' THEN 1
            WHEN thumbnails.type = 'maxres' THEN 5
            ELSE 99
        END
    LIMIT
        1
) AS picked_thumbnails ON true
WHERE
    videos.event_id = $1
ORDER BY
    videos.actual_start_time DESC, videos.actual_end_time DESC,
    videos.youtube_video_id DESC
LIMIT
    coalesce($2::int, NULL)
`

type GetVideosByEventIdParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Limit   *int32      `json:"limit"`
}

type GetVideosByEventIdRow struct {
	YoutubeVideoID   string             `json:"youtube_video_id"`
	Title            string             `json:"title"`
	ActualEndTime    pgtype.Timestamptz `json:"actual_end_time"`
	ActualStartTime  pgtype.Timestamptz `json:"actual_start_time"`
	ViewCount        int64              `json:"view_count"`
	LikeCount        int64              `json:"like_count"`
	DurationSecond   int32              `json:"duration_second"`
	YoutubeChannelID string             `json:"youtube_channel_id"`
	EventID          pgtype.UUID        `json:"event_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ChannelName      string             `json:"channel_name"`
	ThumbnailUrl     string             `json:"thumbnail_url"`
	ThumbnailType    ThumbnailType      `json:"thumbnail_type"`
	ThumbnailWidth   int32              `json:"thumbnail_width"`
	ThumbnailHeight  int32              `json:"thumbnail_height"`
}

func (q *Queries) GetVideosByEventId(ctx context.Context, arg GetVideosByEventIdParams) ([]GetVideosByEventIdRow, error) {
	rows, err := q.db.Query(ctx, getVideosByEventId, arg.EventID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVideosByEventIdRow
	for rows.Next() {
		var i GetVideosByEventIdRow
		if err := rows.Scan(
			&i.YoutubeVideoID,
			&i.Title,
			&i.ActualEndTime,
			&i.ActualStartTime,
			&i.ViewCount,
			&i.LikeCount,
			&i.DurationSecond,
			&i.YoutubeChannelID,
			&i.EventID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChannelName,
			&i.ThumbnailUrl,
			&i.ThumbnailType,
			&i.ThumbnailWidth,
			&i.ThumbnailHeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideos = `-- name: ListVideos :many
SELECT
    youtube_video_id, title, actual_end_time, actual_start_time, view_count, like_count, duration_second, youtube_channel_id, event_id, created_at, updated_at
FROM
    videos
ORDER BY
    created_at DESC, youtube_video_id DESC
LIMIT
    coalesce($1::int, 10)
`

func (q *Queries) ListVideos(ctx context.Context, limit *int32) ([]Video, error) {
	rows, err := q.db.Query(ctx, listVideos, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.YoutubeVideoID,
			&i.Title,
			&i.ActualEndTime,
			&i.ActualStartTime,
			&i.ViewCount,
			&i.LikeCount,
			&i.DurationSecond,
			&i.YoutubeChannelID,
			&i.EventID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertThumbnail = `-- name: UpsertThumbnail :one
INSERT INTO thumbnails (
    url,
    type,
    width,
    height,
    youtube_video_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
ON CONFLICT (youtube_video_id, type) DO UPDATE
SET
    url = $1,
    width = $3,
    height = $4
RETURNING
    url, type, width, height, youtube_video_id
`

type UpsertThumbnailParams struct {
	Url            string        `json:"url"`
	Type           ThumbnailType `json:"type"`
	Width          int32         `json:"width"`
	Height         int32         `json:"height"`
	YoutubeVideoID string        `json:"youtube_video_id"`
}

func (q *Queries) UpsertThumbnail(ctx context.Context, arg UpsertThumbnailParams) (Thumbnail, error) {
	row := q.db.QueryRow(ctx, upsertThumbnail,
		arg.Url,
		arg.Type,
		arg.Width,
		arg.Height,
		arg.YoutubeVideoID,
	)
	var i Thumbnail
	err := row.Scan(
		&i.Url,
		&i.Type,
		&i.Width,
		&i.Height,
		&i.YoutubeVideoID,
	)
	return i, err
}
